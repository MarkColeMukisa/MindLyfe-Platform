import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { ConfigService } from '@nestjs/config';
import { Cron, CronExpression } from '@nestjs/schedule';
import { SecurityLoggerService, SecurityEventType } from './security-logger.service';

export interface VulnerabilityReport {
  timestamp: string;
  scanType: 'dependencies' | 'configuration' | 'runtime' | 'full';
  status: 'clean' | 'warnings' | 'critical';
  summary: VulnerabilitySummary;
  findings: VulnerabilityFinding[];
  recommendations: string[];
}

export interface VulnerabilitySummary {
  totalFindings: number;
  criticalFindings: number;
  highFindings: number;
  mediumFindings: number;
  lowFindings: number;
  packagesScanned: number;
  configsScanned: number;
}

export interface VulnerabilityFinding {
  id: string;
  type: 'dependency' | 'configuration' | 'runtime' | 'code';
  severity: 'critical' | 'high' | 'medium' | 'low';
  title: string;
  description: string;
  affected: string;
  cve?: string;
  cvss?: number;
  recommendation: string;
  fixAvailable: boolean;
  references: string[];
}

@Injectable()
export class VulnerabilityScannerService implements OnModuleInit {
  private readonly logger = new Logger(VulnerabilityScannerService.name);
  private lastScanTime: Date | null = null;
  private scanInProgress = false;

  constructor(
    private readonly configService: ConfigService,
    private readonly securityLogger: SecurityLoggerService,
  ) {}

  async onModuleInit() {
    if (this.configService.get('environment') === 'production') {
      this.logger.log('üîç Vulnerability Scanner initialized for production environment');
      // Run initial scan after startup
      setTimeout(() => this.runFullScan(), 30000); // 30 seconds delay
    }
  }

  /**
   * Scheduled vulnerability scan - runs daily at 2 AM
   */
  @Cron(CronExpression.EVERY_DAY_AT_2AM)
  async scheduledVulnerabilityScan(): Promise<void> {
    if (this.configService.get('environment') === 'production') {
      this.logger.log('üîç Starting scheduled vulnerability scan');
      await this.runFullScan();
    }
  }

  /**
   * Run a full vulnerability scan
   */
  async runFullScan(): Promise<VulnerabilityReport> {
    if (this.scanInProgress) {
      throw new Error('Vulnerability scan already in progress');
    }

    this.scanInProgress = true;
    const startTime = Date.now();

    try {
      this.logger.log('üîç Starting full vulnerability scan');

      const [dependencyFindings, configFindings, runtimeFindings] = await Promise.allSettled([
        this.scanDependencies(),
        this.scanConfiguration(),
        this.scanRuntime(),
      ]);

      const findings: VulnerabilityFinding[] = [
        ...(dependencyFindings.status === 'fulfilled' ? dependencyFindings.value : []),
        ...(configFindings.status === 'fulfilled' ? configFindings.value : []),
        ...(runtimeFindings.status === 'fulfilled' ? runtimeFindings.value : []),
      ];

      const summary = this.calculateSummary(findings);
      const status = this.determineStatus(summary);
      const recommendations = this.generateRecommendations(findings);

      const report: VulnerabilityReport = {
        timestamp: new Date().toISOString(),
        scanType: 'full',
        status,
        summary,
        findings,
        recommendations,
      };

      this.lastScanTime = new Date();
      const duration = Date.now() - startTime;

      this.logger.log(`‚úÖ Vulnerability scan completed in ${duration}ms - Status: ${status}`);

      // Log critical findings
      if (summary.criticalFindings > 0) {
        await this.securityLogger.logSecurityEvent({
          type: SecurityEventType.SECURITY_VIOLATION,
          severity: 'critical',
          details: {
            scanType: 'vulnerability',
            criticalFindings: summary.criticalFindings,
            totalFindings: summary.totalFindings,
          },
        });
      }

      // Send alert if critical vulnerabilities found
      if (status === 'critical') {
        await this.sendVulnerabilityAlert(report);
      }

      return report;

    } catch (error) {
      this.logger.error('Vulnerability scan failed:', error);
      throw error;
    } finally {
      this.scanInProgress = false;
    }
  }

  /**
   * Scan dependencies for known vulnerabilities
   */
  async scanDependencies(): Promise<VulnerabilityFinding[]> {
    const findings: VulnerabilityFinding[] = [];

    try {
      // This would typically use npm audit or similar tools
      // For demonstration, we'll simulate some common vulnerability checks
      
      const packageJson = await this.loadPackageJson();
      const dependencies = { ...packageJson.dependencies, ...packageJson.devDependencies };

      // Check for known vulnerable packages
      const vulnerablePackages = this.getKnownVulnerablePackages();
      
      for (const [packageName, version] of Object.entries(dependencies)) {
        const vulnerability = vulnerablePackages[packageName];
        if (vulnerability && this.isVersionVulnerable(version as string, vulnerability.affectedVersions)) {
          findings.push({
            id: `dep-${packageName}-${vulnerability.cve}`,
            type: 'dependency',
            severity: vulnerability.severity,
            title: `Vulnerable dependency: ${packageName}`,
            description: vulnerability.description,
            affected: `${packageName}@${version}`,
            cve: vulnerability.cve,
            cvss: vulnerability.cvss,
            recommendation: `Update ${packageName} to version ${vulnerability.fixedVersion} or later`,
            fixAvailable: true,
            references: vulnerability.references,
          });
        }
      }

      // Check for outdated packages
      const outdatedPackages = await this.checkOutdatedPackages(dependencies);
      for (const pkg of outdatedPackages) {
        if (pkg.severity === 'high' || pkg.severity === 'critical') {
          findings.push({
            id: `outdated-${pkg.name}`,
            type: 'dependency',
            severity: pkg.severity,
            title: `Outdated package: ${pkg.name}`,
            description: `Package ${pkg.name} is significantly outdated and may contain security vulnerabilities`,
            affected: `${pkg.name}@${pkg.currentVersion}`,
            recommendation: `Update ${pkg.name} to version ${pkg.latestVersion}`,
            fixAvailable: true,
            references: [`https://www.npmjs.com/package/${pkg.name}`],
          });
        }
      }

    } catch (error) {
      this.logger.error('Dependency scan failed:', error);
    }

    return findings;
  }

  /**
   * Scan configuration for security issues
   */
  async scanConfiguration(): Promise<VulnerabilityFinding[]> {
    const findings: VulnerabilityFinding[] = [];

    try {
      // Check environment configuration
      const configChecks = [
        {
          check: () => this.configService.get('jwt.secret') === 'dev-secret-key-change-in-production',
          finding: {
            id: 'config-jwt-default-secret',
            type: 'configuration' as const,
            severity: 'critical' as const,
            title: 'Default JWT secret in production',
            description: 'JWT secret is using default development value in production environment',
            affected: 'JWT configuration',
            recommendation: 'Set a strong, unique JWT secret using AWS Secrets Manager',
            fixAvailable: true,
            references: ['https://jwt.io/introduction/'],
          }
        },
        {
          check: () => this.configService.get('cors.origin') === '*',
          finding: {
            id: 'config-cors-wildcard',
            type: 'configuration' as const,
            severity: 'high' as const,
            title: 'CORS wildcard origin',
            description: 'CORS is configured to allow all origins (*) which poses security risks',
            affected: 'CORS configuration',
            recommendation: 'Restrict CORS origins to specific trusted domains',
            fixAvailable: true,
            references: ['https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS'],
          }
        },
        {
          check: () => !this.configService.get('helmet.hsts'),
          finding: {
            id: 'config-missing-hsts',
            type: 'configuration' as const,
            severity: 'medium' as const,
            title: 'Missing HSTS configuration',
            description: 'HTTP Strict Transport Security (HSTS) is not configured',
            affected: 'Security headers',
            recommendation: 'Enable HSTS with appropriate max-age and includeSubDomains',
            fixAvailable: true,
            references: ['https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Strict-Transport-Security'],
          }
        },
        {
          check: () => this.configService.get('environment') === 'production' && this.configService.get('logging.level') === 'debug',
          finding: {
            id: 'config-debug-logging-prod',
            type: 'configuration' as const,
            severity: 'medium' as const,
            title: 'Debug logging in production',
            description: 'Debug logging is enabled in production environment',
            affected: 'Logging configuration',
            recommendation: 'Set log level to "info" or "warn" in production',
            fixAvailable: true,
            references: [],
          }
        }
      ];

      for (const { check, finding } of configChecks) {
        if (check()) {
          findings.push(finding);
        }
      }

    } catch (error) {
      this.logger.error('Configuration scan failed:', error);
    }

    return findings;
  }

  /**
   * Scan runtime environment for security issues
   */
  async scanRuntime(): Promise<VulnerabilityFinding[]> {
    const findings: VulnerabilityFinding[] = [];

    try {
      // Check Node.js version
      const nodeVersion = process.version;
      const majorVersion = parseInt(nodeVersion.slice(1).split('.')[0]);
      
      if (majorVersion < 18) {
        findings.push({
          id: 'runtime-node-version',
          type: 'runtime',
          severity: 'high',
          title: 'Outdated Node.js version',
          description: `Node.js version ${nodeVersion} is outdated and may contain security vulnerabilities`,
          affected: `Node.js ${nodeVersion}`,
          recommendation: 'Update to Node.js 18 LTS or later',
          fixAvailable: true,
          references: ['https://nodejs.org/en/about/releases/'],
        });
      }

      // Check memory usage
      const memoryUsage = process.memoryUsage();
      const heapUsedMB = memoryUsage.heapUsed / 1024 / 1024;
      
      if (heapUsedMB > 1024) { // 1GB
        findings.push({
          id: 'runtime-high-memory',
          type: 'runtime',
          severity: 'medium',
          title: 'High memory usage',
          description: `Application is using ${Math.round(heapUsedMB)}MB of heap memory`,
          affected: 'Runtime memory',
          recommendation: 'Monitor for memory leaks and optimize memory usage',
          fixAvailable: false,
          references: [],
        });
      }

      // Check for exposed debug ports
      if (process.execArgv.some(arg => arg.includes('--inspect'))) {
        findings.push({
          id: 'runtime-debug-port',
          type: 'runtime',
          severity: 'critical',
          title: 'Debug port exposed',
          description: 'Node.js debug port is exposed which allows remote code execution',
          affected: 'Node.js debug interface',
          recommendation: 'Remove --inspect flags from production startup',
          fixAvailable: true,
          references: ['https://nodejs.org/en/docs/guides/debugging-getting-started/'],
        });
      }

    } catch (error) {
      this.logger.error('Runtime scan failed:', error);
    }

    return findings;
  }

  /**
   * Get the latest vulnerability report
   */
  getLastScanReport(): { lastScanTime: Date | null; scanInProgress: boolean } {
    return {
      lastScanTime: this.lastScanTime,
      scanInProgress: this.scanInProgress,
    };
  }

  /**
   * Load package.json for dependency analysis
   */
  private async loadPackageJson(): Promise<any> {
    try {
      const fs = await import('fs/promises');
      const path = await import('path');
      const packagePath = path.join(process.cwd(), 'package.json');
      const packageContent = await fs.readFile(packagePath, 'utf-8');
      return JSON.parse(packageContent);
    } catch (error) {
      this.logger.warn('Could not load package.json:', error.message);
      return { dependencies: {}, devDependencies: {} };
    }
  }

  /**
   * Get known vulnerable packages (this would typically come from a vulnerability database)
   */
  private getKnownVulnerablePackages(): Record<string, any> {
    return {
      'lodash': {
        cve: 'CVE-2021-23337',
        severity: 'high',
        description: 'Command injection vulnerability in lodash',
        affectedVersions: ['<4.17.21'],
        fixedVersion: '4.17.21',
        cvss: 7.2,
        references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-23337'],
      },
      'axios': {
        cve: 'CVE-2021-3749',
        severity: 'medium',
        description: 'Regular expression denial of service in axios',
        affectedVersions: ['<0.21.2'],
        fixedVersion: '0.21.2',
        cvss: 5.3,
        references: ['https://nvd.nist.gov/vuln/detail/CVE-2021-3749'],
      },
    };
  }

  /**
   * Check if a version is vulnerable
   */
  private isVersionVulnerable(version: string, affectedVersions: string[]): boolean {
    // Simplified version checking - in production, use a proper semver library
    for (const affected of affectedVersions) {
      if (affected.startsWith('<')) {
        const targetVersion = affected.slice(1);
        if (version < targetVersion) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Check for outdated packages
   */
  private async checkOutdatedPackages(dependencies: Record<string, string>): Promise<any[]> {
    // This would typically use npm outdated or similar
    // For demonstration, return some mock data
    return [
      {
        name: 'express',
        currentVersion: '4.17.1',
        latestVersion: '4.18.2',
        severity: 'medium',
      },
    ];
  }

  /**
   * Calculate vulnerability summary
   */
  private calculateSummary(findings: VulnerabilityFinding[]): VulnerabilitySummary {
    return {
      totalFindings: findings.length,
      criticalFindings: findings.filter(f => f.severity === 'critical').length,
      highFindings: findings.filter(f => f.severity === 'high').length,
      mediumFindings: findings.filter(f => f.severity === 'medium').length,
      lowFindings: findings.filter(f => f.severity === 'low').length,
      packagesScanned: 0, // Would be calculated from actual package scan
      configsScanned: 4, // Number of config checks performed
    };
  }

  /**
   * Determine overall status
   */
  private determineStatus(summary: VulnerabilitySummary): 'clean' | 'warnings' | 'critical' {
    if (summary.criticalFindings > 0) {
      return 'critical';
    }
    if (summary.highFindings > 0 || summary.mediumFindings > 3) {
      return 'warnings';
    }
    return 'clean';
  }

  /**
   * Generate recommendations
   */
  private generateRecommendations(findings: VulnerabilityFinding[]): string[] {
    const recommendations = new Set<string>();

    if (findings.some(f => f.type === 'dependency')) {
      recommendations.add('Run "npm audit fix" to automatically fix dependency vulnerabilities');
      recommendations.add('Consider using "npm audit" regularly in your CI/CD pipeline');
    }

    if (findings.some(f => f.type === 'configuration')) {
      recommendations.add('Review and harden security configuration settings');
      recommendations.add('Use AWS Secrets Manager for sensitive configuration values');
    }

    if (findings.some(f => f.type === 'runtime')) {
      recommendations.add('Update Node.js to the latest LTS version');
      recommendations.add('Monitor runtime metrics and set up alerts for anomalies');
    }

    if (findings.length === 0) {
      recommendations.add('Continue regular security scans and monitoring');
      recommendations.add('Keep dependencies and runtime updated');
    }

    return Array.from(recommendations);
  }

  /**
   * Send vulnerability alert
   */
  private async sendVulnerabilityAlert(report: VulnerabilityReport): Promise<void> {
    try {
      const alertMessage = `üö® CRITICAL VULNERABILITIES DETECTED\n\n` +
        `Critical: ${report.summary.criticalFindings}\n` +
        `High: ${report.summary.highFindings}\n` +
        `Total: ${report.summary.totalFindings}\n\n` +
        `Immediate action required!`;

      // Send to monitoring webhook if configured
      const webhookUrl = this.configService.get('monitoring.webhook');
      if (webhookUrl) {
        const fetch = (await import('node-fetch')).default;
        await fetch(webhookUrl, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            type: 'vulnerability_alert',
            severity: 'critical',
            message: alertMessage,
            report: report.summary,
          }),
        });
      }

      this.logger.error(alertMessage);

    } catch (error) {
      this.logger.error('Failed to send vulnerability alert:', error);
    }
  }

  /**
   * Health check for vulnerability scanner
   */
  async healthCheck(): Promise<{ status: string; details: any }> {
    try {
      const lastScan = this.getLastScanReport();
      
      return {
        status: 'healthy',
        details: {
          lastScanTime: lastScan.lastScanTime,
          scanInProgress: lastScan.scanInProgress,
          scheduledScans: 'Daily at 2 AM',
        },
      };
    } catch (error) {
      return {
        status: 'unhealthy',
        details: { error: error.message },
      };
    }
  }
} 